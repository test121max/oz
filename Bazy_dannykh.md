## Базы данных <!-- {docsify-ignore} -->

### Самый взрослый пользователь

Сложность: **простая**

<!--Автор: @igor.lyubin-->

#### Задача:

Есть таблица users. столбцы: userID, name, age.

Найдите самого взрослого пользователя.

#### Ответ:

<details><summary>Решение 1</summary>
<p>

```sql
SELECT TOP 1 * FROM users ORDER BY age DESC
```

</p>
</details>

<details><summary>Решение 2</summary>
<p>

```sql
SELECT * FROM users WHERE age = (SELECT MAX(age) FROM users)
```

</p>
</details>

______________________________________________________________________

### Жители Москвы

Сложность: **простая**

<!--Автор: @igor.lyubin-->

#### Задача:

Есть таблица users. столбцы: userID, name, age, locationID.

Есть таблица location. столбцы: ID, locationName.

Найдите 10 пользователей, которые живут в Москве.

#### Ответ:

<details><summary>Решение</summary>
<p>

```
SELECT TOP 10 * FROM users u JOIN location l ON u.locationID = l.ID WHERE locationName = 'Москва'
```

</p>
</details>

#### Дополнительные вопросы:

Q: *Как выбрать только пользователей на букву A?*

A:

<details><summary>Решение</summary>
<p>

```
SELECT TOP 10 * FROM users u JOIN location l ON u.locationID = l.ID WHERE locationName = 'Москва' AND name LIKE 'А%'
```

</p>
</details>

______________________________________________________________________

### Большая корзина

Сложность: **средняя**

<!--Автор: @igor.lyubin-->

#### Задача:

Есть таблица carts. столбцы: userID, itemID, quantity.

Найдите пользователей с большой корзиной, тех у кого общее число товаров больше 300.

#### Ответ:

<details><summary>Решение</summary>
<p>

```
SELECT userID FROM carts GROUP BY userID HAVING SUM(quantity) > 300
```

</p>
</details>

#### Дополнительные вопросы:

Q: *Как отсечь неавторизованных пользователей?*

A: Добавить `WHERE userID != 0`

______________________________________________________________________

### Индекс

Сложность: **средняя**

<!--Автор: @andrey.zakharov-->

#### Вопрос:

Что такое индекс?

#### Ответ:

<details><summary>Решение</summary>
<p>

**Индекс** — это метод настройки производительности, позволяющий быстрее извлекать записи.
Индекс создает запись для каждого значения, которое появляется в индексированных столбцах.

</p>
</details>

#### Дополнительные вопросы:

Q: *Какие существуют типы индексов?*

A:

<details><summary>Решение</summary>
<p>

- **Кластеризованный индекс** сортирует и хранит строки данных таблицы или представления в порядке, определяемом ключом кластеризованного индекса. Кластеризованный индекс реализуется в виде сбалансированного дерева, которое поддерживает быстрое получение строк по значениям ключа кластеризованного индекса.
- **Некластеризованный индекс** можно определить в таблице или представлении вместе с кластеризованным индексом или в куче. Каждая строка некластеризованного индекса содержит некластеризованное ключевое значение и указатель на строку. Этот указатель определяет строку данных кластеризованного индекса или кучи, содержащую ключевое значение. Строки в индексе хранятся в порядке, определяемом значениями ключа индекса, но до создания кластеризованного индекса в таблице нет никакой гарантии того,
  что строки данных будут расположены в каком-либо определенном порядке.
- **Хэш**. При использовании хэш-индекса доступ к данным осуществляется через хэш-таблицу в памяти. Хэш-индексы используют фиксированный размер памяти, который зависит от числа контейнеров.

</p>
</details>

______________________________________________________________________

### Ключи

Сложность: **средняя**

<!--Автор: @andrey.zakharov-->

#### Вопрос:

Что такое primary key, constraints, foreign key?

#### Ответ:

<details><summary>Решение</summary>
<p>

- **Foreign key** (внешний ключ) позволяет установить связь между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы.
- **Constraints** (уникальное ограничение) — это одно поле или комбинация полей, которые однозначно определяют запись.
- **Primary key** (первичный ключ) является полем в таблице, которое однозначно идентифицирует каждую строку/запись в таблице базы данных. Первичные ключи должны содержать уникальные значения. Первичный ключ столбец не может иметь значения NULL.

</p>
</details>

______________________________________________________________________

### Хранимка

Сложность: **средняя**

<!--Автор: @andrey.zakharov-->

#### Вопрос:

Что такое хранимая процедура?

#### Ответ:

<details><summary>Решение</summary>
<p>

**Хранимая процедура** - компилируемый набор SQL-инструкций, являющийся частью базы данных и хранимый на сервере. Есть много общего между ХП и обычными процедурами языков программирования: они могут иметь входные параметры и выходной результат, они могут как выполнять различные численные вычисления, так и выполнять стандартные операции с БД. Как и в процедурах других языков программирования, в них могут быть циклы и ветвления.

</p>
</details>

______________________________________________________________________

### Функции

Сложность: **средняя**

<!--Автор: @andrey.zakharov-->

#### Вопрос:

Какие существуют виды функций?

#### Ответ:

<details><summary>Решение</summary>
<p>

- **Агрегатные функции** выполняют вычисление на наборе значений и возвращают одиночное значение. Они допускаются в списке выбора или в предложении HAVING инструкции SELECT. Агрегатную функцию можно использовать в сочетании с предложением GROUP BY для статистических вычислений на основе категорий строк. Используйте предложение OVER для вычисления статистического значения на основе определенного диапазона значений. Предложение OVER не может следовать за агрегатными функциями GROUPING и GROUPING_ID. Все агрегатные функции являются детерминированными. Это означает, что они всегда возвращают одинаковый результат для одинаковых входных значений.
- **Аналитические функции** вычисляют статистическое значение на основе группы строк. Однако, в отличие от агрегатных функций, аналитические функции могут возвращать несколько строк для каждой группы. Аналитические функции можно использовать для вычисления скользящих средних, промежуточных итогов, процентных долей или первых N результатов в группе.
- **Ранжирующие функции** возвращают ранжирующее значение для каждой строки в секции. В зависимости от используемой функции значения некоторых строк могут совпадать. Ранжирующие функции являются недетерминированными.
- **Функции наборов строк** возвращают объект, который можно использовать так же, как табличные ссылки в инструкции SQL.
- **Скалярные функции** обрабатывают и возвращают одиночное значение.

</p>
</details>

______________________________________________________________________

### Profiler

Сложность: **средняя**

<!--Автор: @andrey.zakharov-->

#### Вопрос:

Для чего используют Profiler?

#### Ответ:

<details><summary>Решение</summary>
<p>

Приложение **SQL Server Profiler** — это интерфейс для создания трассировок и управления ими, а также для анализа и воспроизведения полученных результатов. События сохраняются в файле трассировки, который затем может быть проанализирован или использован для воспроизведения определенных последовательностей шагов для выявления возникших проблем.

</p>
</details>

______________________________________________________________________

### Инструменты для просмотра планов запросов

Сложность: **средняя**

<!--Автор: @andrey.zakharov-->

#### Вопрос:

Какие инструменты можно использовать, для просмотра планов запросов и для проверки нагрузки?

#### Ответ:

<details><summary>Решение</summary>
<p>

- SentryOne Plan Explorer
- SQLQueryStress

</p>
</details>

______________________________________________________________________

### Клиенты, курьеры, товары, заказы

Сложность: **сложная**

<!--Автор: @andrey.zakharov-->

#### Задача:

Тестовое задание

```sql
CREATE TABLE test.Client
(
    ID INT IDENTITY(1, 1) NOT NULL,
    Name VARCHAR(50)
        PRIMARY KEY CLUSTERED ([ID] ASC)
);

CREATE TABLE test.Courier
(
    ID INT IDENTITY(1, 1) NOT NULL,
    Name VARCHAR(50)
        PRIMARY KEY CLUSTERED ([ID] ASC)

CREATE TABLE test.[Item]
(
    ID INT IDENTITY(1, 1) NOT NULL,
    ItemName VARCHAR(50)
        PRIMARY KEY CLUSTERED ([ID] ASC)
);

CREATE TABLE test.[ORDER]
(
    ID INT IDENTITY(1, 1) NOT NULL,
    ClientID INT,
    OrderName VARCHAR(50),
    OrderDate DATETIME
        PRIMARY KEY CLUSTERED ([ID] ASC)
);

CREATE TABLE test.ItemInOrder
(
    OrderID INT,
    ItemID INT
);

ALTER TABLE test.[ORDER] WITH CHECK
ADD
    FOREIGN KEY ([ClientID]) REFERENCES [test].[Client] ([ID]);
ALTER TABLE test.[ItemInOrder] WITH CHECK
ADD
    FOREIGN KEY ([OrderID]) REFERENCES [test].[ORDER] ([ID]);
ALTER TABLE test.[ItemInOrder] WITH CHECK
ADD
    FOREIGN KEY ([ItemID]) REFERENCES [test].[Item] ([ID]);
```

#### Дополнительные вопросы:

Q: *Как вывести имена клиентов, начинающиеся на букву "А"?*

A: `SELECT c.Name FROM test.client c WHERE c.name LIKE 'A%'`

Q: \*Как вывести среднее количество товаров в заказе?

A: `SELECT AVG(iio.ItemID) FROM test.ItemInOrder iio`

Q: *Как вывести клиентов, у которых нет заказов?*

A: `SELECT c.id, c.Name FROM test.Client c LEFT JOIN test.[ORDER] o ON c.ID = o.ClientID WHERE o.id IS null`

Q: *Как вывести имена клиентов, которые повторяются больше трех раз?*

A: `SELECT c.Name FROM test.Client c GROUP BY Name HAVING COUNT(c.name)>3`

Q: *Как вывести имя клиента, у которого больше всего заказов?*

A: `SELECT c.Name FROM test.Client c WHERE c.ID = (SELECT TOP 1 o.clientid FROM test.[ORDER] o GROUP BY o.ClientID ORDER BY COUNT (o.ClientID) desc)`

Q: *Как вывести заказ, в котором больше всего товаров?*

A: `SELECT o.OrderName FROM test.[ORDER] o WHERE o.ID = (SELECT TOP 1 iio.OrderID FROM test.ItemInOrder iio GROUP BY iio.OrderID ORDER BY COUNT (iio.OrderID) desc)`

Q: *Как вывести товар, который реже всего заказывают?*

A: `SELECT i.ItemName FROM test.Item i WHERE i.ID = (SELECT TOP 1 iio.ItemID FROM test.ItemInOrder iio GROUP BY iio.ItemID ORDER BY COUNT (iio.OrderID) asc)`

Q: *Как вывести заказы, которые были сделаны за последние три дня (от текущего времени)?*

A: `SELECT o.OrderName, o.OrderDate FROM test.[ORDER] o WHERE o.OrderDate > DATEADD(DAY, -3, GETDATE())`

Q: *Как вывести имена клиентов и признак были ли у него заказы (1 - был заказ, 0 - не было заказов)?*

A: `SELECT c.Name, CASE WHEN o.id IS NULL THEN 0 ELSE 1 end [order] FROM test.Client c LEFT JOIN test.[ORDER] o ON c.ID=o.ClientID`

Q: *Как вывести с 5 по 10 имена клиентов, отсортированных в алфавитном порядке?*

A: `SELECT TOP 5 c.Name FROM test.Client c WHERE c.Name NOT IN (SELECT TOP 5 Name FROM test.Client cc ORDER BY cc.Name asc) ORDER BY c.Name asc`

Q: *Как вывести имена всех клиентов и курьеров?*

A:

```
SELECT c.name FROM test.Client c
UNION ALL
SELECT co.name FROM test.Courier co
```

Q: *Как найти кол-во заказов каждого клиента в год?*

A:

```
WITH order_CTE (ClientID,  ID, [Year])  
AS  
(  
    SELECT o.ClientID , o.ID,  YEAR(o.OrderDate) AS [Year] 
    FROM test.[ORDER] o 
)  
SELECT clientid, COUNT(ID) AS Total, [Year]   
FROM order_CTE  
GROUP BY [Year]  , clientid  
ORDER BY clientid, [Year]  ; 
```

### Цикл

Сложность: **сложная**

<!--Автор: @andrey.zakharov-->

#### Задача:

Как написать цикл, который выведет все нечетные цифры от 1 до 10?

#### Ответ:

<details><summary>Решение</summary>
<p>

```
DECLARE @cnt INT = 1;
WHILE @cnt < 10
BEGIN
    SELECT @cnt;
    SET @cnt = @cnt + 2;
END;
```

</p>
</details>
