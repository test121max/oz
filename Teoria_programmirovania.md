## Теория программирования

### Чем функция отличается от процедуры?

Сложность: **низкая**
Грейд: **16**

Функция возвращает значение, а процедура просто выполняет команды.
Функция имени происходит из математики. Он используется для вычисления значения
на основе входных данных. Процедура - это набор команд, которые могут
выполняться по порядку.

Q: *Что такое метод?*

Q: *Для чего используется return void?*

### Принципы ООП

Сложность: **низкая**
Грейд: **16**

Инкапсуляция, Наследование, Полиморфизм, (Абстракция).

Q: *Какие преимущества ООП по сравнению с императивным программированием? (17 грейд)*

### Когда использовать цикл for, а когда while

Сложность: **низкая**
Грейд: **16**

 - **for** используется, когда число итераций известно.
(есть переменная или константа, которая определяет это количество)
 - **while** используется, когда существует возможность, что цикл не выполнится ни разу.

### Базовые методы работы со строкой

Сложность: **низкая**
Грейд: **16**

Знает методы для своего ЯП: удаления или вставки подстроки (Remove, Insert),
получения подстроки (Substring), возвращения длины строки (Length),
модификации всей строки или ее части (Remove, Replace),
представления строки в нижнем или верхнем регистре (ToUpper, ToLower).

Q: *Что такое регулярные выражения? (17 грейд)*


### Модификаторы доступа и зачем их применять

Сложность: **средняя**
Грейд: **16**

Модификаторы доступа организуют инкапсуляцию данных.

Чтобы сказать компилятору, что что-то должно быть доступно для всех,
используется ключевое слово public.

Чтобы поля были защищены от вмешательства, используется ключевое слово private
— оно делает члены класса доступными только внутри самого класса.


### Создать и запустить простое консольное приложение

Сложность: **низкая**
Грейд: **16**

#### Задачка

Написать код, который из консоли получает от пользователя цифру и говорит четная оно или не четная.

#### Пример ответа

```python
a = int(input("Введите число: "))
if a % 2 == 0:
    print("четное")
else:
    print("нечетное")
```

Q: *Как можно изменить код, чтобы предотвратить ввод пользователем строки? (17 грейд)*

### В чем разница между ссылкой и значением?

Сложность: **низкая**
Грейд: **16**

Ссылка — это объект, указывающий на определенные данные, но не хранящий их.

Значение - элемент данных, являющийся одним из типов данных, который может
соответствовать некоторому состоянию переменной или константе соответствующего типа.

Q: *Где хранятся ссылки, а где значения?*

Q: *Что такое указатель? (17 грейд)*


#### Задачка (16 грейд)

```python
a = [0]
b = a
a[0] = 1
# вопрос - Что выведет print(b)?
# ответ - [1]

b[0] = 2
# вопрос - Что выведет print(a)?
# ответ - [2]
```

### В чем разница между компилятором и интерпретатором

Сложность: **низкая**
Грейд: **16**

Компилятор преобразует исходный код к близкому к машинному коду.

Интерпретатор позволяет выполнять некоторое представление программы, налету
преобразуя в машинный код.

Q: *А есть JIT компиляция, можешь рассказать в чем разница? (17 грейд)*


### Что такое CodeStyle?

Сложность: **средняя**
Грейд: **16, 17**

CodeStyle - набор правил и соглашений, используемых при написании исходного
кода на некотором языке программирования.
Наличие общего стиля программирования облегчает понимание и поддержание
исходного кода, написанного более чем одним программистом, а также упрощает
взаимодействие нескольких человек при разработке программного обеспечения.

Q: *Может ли название переменой или функции начинаться с цифры? (16 грейд)*

A: Короткий ответ - нет.
Более подробный ответ - это бы породило хаос при попытке отделить числа от переменных.

Q: *Какие способы именования переменных и функций вы знаете? (16 грейд)*

A: Наиболее часто под способом именования подразумевается формат многословных идентификаторов.
Основные форматы: camelCase, UpperCamelCase, lowercase_separated_by_underscores, CAPITALIZED_WITH_UNDERSCORES, kebab-case.
Однако упоминаение кандидатом венгерской нотации тоже идет в плюс.

Q: *Для чего в функциях используется префикс is? (17 грейд)*

A: Для явного указания что возвращаемое значение имеет булевый тип.

### Что такое отладчик? Как он используется?

Сложность: **средняя**
Грейд: **16, 17**

Программный инструмент, позволяющий наблюдать за выполнением исследуемой
программы, останавливать и перезапускать её, прогонять в замедленном темпе,
изменять значения в памяти и возвращать назад к определенному шагу.

Q: *Какие еще инструменты используются для отладки кода? (17 грейд)*

A:
- Вставка принтов (println)
- Запуск под трассировочными утилитами типа strace, dtrace
- Запуск под анализаторами утечек памяти
- Запуск программы в режиме "говорливости" или отладки
- Снифферы для анализа сетевога трафика
- Логи систем, с которыми взаимодействует программа
- Логи системы, в которой запущена программа
- "Developer Tools" в браузере
- git bisect

Q: *Почему println плохо использовать для отладки кода? (17 грейд)*

A:
- Такая отладка никак не облегчает будущие отладки
- Принты не управляемы, они не интегрируются в систему логирования
- Обычно всегда есть более удобный и быстрый способ отладки
- Принты требуют модификаций кода, и в конце отладки нужен откат этих модификаций
- Другой негативный опыт использования принтов от кандидата

Q: *Для чего используется профилировщик? (17 грейд)*

А:
- Для поиска участков кода которые запускаются чаще/дольше всего
- Чтобы понять где тормозит

### Работа с библиотеками для api, для бд, для логов, для конфигов

Сложность: **средняя**
Грейд: **17**

Рассказывает про библиотеки, с которыми работал для своего ЯП.

(Для 17 грейда ожидается, что работал с rest-запросами, работал с файлами и работал бд)


### Что такое Генератор в python?

Сложность: **средняя**
Грейд: **17**

Генератор — это объект, который сразу при создании не вычисляет значения всех
своих элементов. Он хранит в памяти только последний вычисленный элемент,
правило перехода к следующему и условие, при котором выполнение прерывается.
Вычисление следующего значения происходит лишь при выполнении метода next().
Предыдущее значение при этом теряется.

### Какие фреймворки тестирования использовал?

Сложность: **низкая**
Грейд: **17**

Фреймворки используемые для написания и запусков тестов, например Junit, pytest, cucumber, testNg и др.

#### Задача

Написать пример простого теста с использованием знакомого фреймворка.

Q: *Как добавить выполнение кода до и после теста, до и после набора тестов?*

Q: *Как работать с параметризацией?*

Q: *Что такое заглушки, когда их использовать нужно?*

### Что такое Линтер?

Сложность: **средняя**
Грейд: **17**

Линтер - специальная утилита которая проверяет код на соответствие стандартам.
К примеру в Python - PEP8.

Q: *Для чего используются линтеры?*

А:
- Для приведения к стилистическому единообразию кодовой базы
- Для ограничения использования практик признанных нежелательными
- Для автоматизированного поиска некоторых типов ошибок

Q: *Какие линтеры вы используете для вашего ЯП?*

### Что такое Лямбда-выражения?

Сложность: **средняя**
Грейд: **17**

Лямбда-выражения - специальный синтаксис, который применяется для объявления
анонимных функций по месту их использования, допускает замыкание на лексический
контекст, в котором использовано.

Q: *Что такое анонимные функции?*

A: Функция у которой нет имени. К такой функции нельзя обратиться по имени, но можно:
- Вызвать по месту объявления
- Передать в другую функцию
- Вернуть из другой функции

Q: *Что такое замыкание?*

А:
- Это функция которая определена внутри другой функции и использующая локальные переменные этой внешней функции.
- Это способ хранить данные внутри функции.

### Принцип DRY

Сложность: **средняя**
Грейд: **17**

DRY - Don’t repeat yourself
Принцип разработки программного обеспечения, нацеленный на снижение повторения
информации различного рода, особенно в системах со множеством слоёв
абстрагирования.
Принцип DRY формулируется как: «Каждая часть знания должна иметь единственное,
непротиворечивое и авторитетное представление в рамках системы».

16 грейд - может не знать аббревиатуру, но сам принцип, почему и зачем лучше так,
может рассказать.

Q: *Какие еще знаешь принципы разработки ПО("чистого" кода)?*

A:
- KISS - Keep it simple, stupid
- YAGNI - You aren't gonna need it
- SOLID


### Что такое сериализация и десериализация?

Сложность: **средняя**
Грейд: **17**

Сериализация - это механизм преобразования объекта в поток байтов или текста.
Десериализация берет ряд байтов или плоский файл и преобразует его в объект.

### Зачем нужна инкапсуляция и как реализовать ее на практике

Сложность: **средняя**
Грейд: **17**

Инкапсуляция — это заключение данных и функционала в оболочку.
В объектно-ориентированном программировании в роли оболочки выступают классы.
Они не только собирают переменные и методы в одном месте, но и защищают их от
вмешательства извне (сокрытие).

### Абстрактные классы, интерфейсы и в чем разница?

Сложность: **средняя**
Грейд: **17**

Абстрактный класс — это класс, у которого не реализован один или больше методов
(некоторые языки требуют такие методы помечать специальными ключевыми словами).
Интерфейс — это абстрактный класс, у которого ни один метод не реализован,
все они публичные и нет переменных класса.

Интерфейс нужен для общего описания, абстрактный класс для семейства классов
с общими структурами.

### Связанные списки

Сложность: **средняя**
Грейд: **17, 18**

Структура данных, состоящая из элементов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или предыдущий узел списка. Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

Q: *Какая реализация связанного списка есть в стандартной библиотеке твоего языка программирования?*

- Golang: container/list
- Python: отсутствует, но можно использовать collections.deque
- Java, C#: LinkedList

Q: *Когда стоит использовать связанные списки? (грейд 18+)*
- Для реализации очередей, стеков, LRU-кеша
- Когда важна сложность вставки/удаления т.к. у связанных списков она O(1)

### Множество Set

Сложность: **средняя**
Грейд: **17, 18**

Set — коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.

Q: *Что такое множество?*

Q: *Какие операции возможны над множеством? Какие операции над множеством реализованы в твоем языке программирования?*

### Ассоциативный массив. Хэш-функция. Хэш-таблица

Сложность: **средняя**
Грейд: **17, 18**

Хеш-функция — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, называется хешированием.

Q: *Какие знаешь алгоритмы хэширования? (грейд 18)*

Ассоциативный массив — тип данных, позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу.

Хэш-таблица - Это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять операций: добавление новой пары, операция поиска и операция удаления пары по ключу.

Важное свойство хеш-таблиц состоит в том, что, при некоторых разумных допущениях, все три операции (поиск, вставка, удаление элементов) в среднем выполняются за время
O(1).

Q: *Что будет если добавлять данные с одинаковым ключом?*

Q: *Что будет если передать ключу значение null/nil/None?*

Q: *Как реализованы хэш-таблицы в твоем языке программирования?*

Q: *Что такое коллизия? (грейд 18)*

### Что такое boxing/unboxing?

Сложность: **средняя**
Грейд: **17, 18**

Упаковка представляет собой процесс преобразования типа значения в тип object или в любой другой тип интерфейса, реализуемый этим типом значения.

Распаковка является явным преобразованием из типа object в тип значения или из типа интерфейса в тип значения, реализующего этот интерфейс.

Q: *Работает ли обобщение для простых (значимых) типов данных? Как это реализовано? (грейд 18+)*

### Что такое обобщение (дженерики)?

Сложность: **средняя**
Грейд: **17, 18**

Обобщённое программирование — парадигма программирования, заключающаяся в таком описании данных и алгоритмов, которое можно применять к различным типам данных, не меняя само это описание.

Вместо описания отдельного типа в обобщённом программировании применяется описание семейства типов, имеющих общий интерфейс и семантическое поведение. Набор требований, описывающий интерфейс и семантическое поведение, называется концепцией. Таким образом, написанный в обобщённом стиле алгоритм может применяться для любых типов, удовлетворяющих его своими концепциями.

Q: *Какой принцип ООП реализуют обобщения? (грейд 18)*

### Что такое "утиная" типизация?

Сложность: **низкая**
Грейд: **18, 19**

Утиная типизация - определение факта реализации определённого интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов.
"Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка."

Q: *В каких языках встречается данная типизация и почему?*

Q: *Какие минусы у данного подхода?*

### Что такое паттерны (шаблоны проектирования в ООП)?

Сложность: **средняя**
Грейд: **18, 19**

Паттерн представляет определенный способ построения программного кода для решения часто встречающихся проблем проектирования. Определен некоторый набор общих формализованных проблем, которые довольно часто встречаются, и паттерны предоставляют ряд принципов для решения этих проблем.

Q: *Какие есть порождающие шаблоны?*

Q: *Какие есть структурные шаблоны?*

Q: *Какие есть поведенческие шаблоны?*

Q: *Зачем Одиночка если есть статик методы?*

### Принципы SOLID

Сложность: **высокая**
Грейд: **18, 19**

S - Принцип единственной ответственности (single responsibility principle)
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

O - Принцип открытости/закрытости (open–closed principle)
«программные сущности должны быть открыты для расширения, но закрыты для модификации».

L - Принцип подстановки Лисков (Liskov substitution principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы».
Производный класс должен быть взаимозаменяем с родительским классом.

I - Принцип разделения интерфейса (interface segregation principle)
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения».

D - Принцип инверсии зависимостей (dependency inversion principle)
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное».

### Что такое JIT. Где и когда выполняется код

Сложность: **средняя**
Грейд: **18, 19**

JIT (Just-in-time)-компиляция — технология увеличения производительности программных систем, использующих промежуточный код (байт-код, IL и др), путём компиляции промежуточного кода в машинный код или в другой формат непосредственно во время работы программы.
Для исполнения промежуточного кода и управления ресурсами используются так называемые "виртуальные машины". Примеры: JVM (например реализация HotSpot), .NET, LLVM и др.

Q: *Что такое AOT-компиляция?*

### Что такое GC? Как работает сборщик мусора

Сложность: **высокая**
Грейд: **18, 19**

Сборка мусора в программировании — одна из форм автоматического управления памятью. Специальный процесс, называемый сборщиком мусора (англ. garbage collector), периодически освобождает память, удаляя объекты, которые уже не будут востребованы приложениями.

В системе со сборкой мусора обязанность освобождения памяти возлагается на среду исполнения программы. Для этого в состав среды исполнения включается специальный программный модуль, называемый «сборщиком мусора». Этот модуль периодически запускается, определяет, какие из созданных в динамической памяти объектов больше не используются, и освобождает занимаемую ими память.

Периодичность запуска сборщика мусора определяется особенностями системы. Сборщик может работать в фоновом режиме, запускаясь при неактивности программы (например, когда программа простаивает, ожидая ввода данных пользователем). Сборщик мусора запускается безусловно, останавливая выполнение программы (англ. Stop-the-world), когда очередную операцию выделения памяти оказывается невозможно выполнить из-за того, что вся доступная память исчерпана. После освобождения памяти прерванная операция выделения памяти возобновляется, и программа продолжает исполняться дальше.

Q: *Что такое достижимость объекта - алгоритм подсчета ссылок? (грейд 19)*

Q: *Почему происходят утечки памяти?*

### Ассоциации в ООП: Композиция и агрегация

Сложность: **средняя**
Грейд: **19**

Агрегация (агрегирование по ссылке) — отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.
Частый случай, когда один объект создается где-то отдельно и ссылка на него передается в конструктор объекта-контейнера.

Композиция (агрегирование по значению) — более строгий вариант агрегирования, когда включаемый объект может существовать только как часть контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.
Частый случай, когда второй объект инициализируется при вызове конструктора объекта-контейнера.

Q: *Когда использовать наследование, а когда композицию?*

### Оценка сложности ПО. Цикломатическая сложность, вычеслительная сложность (Big O нотация)

Сложность: **высокая**
Грейд: **19**

Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Например, если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только единственный маршрут через код. Если код имеет единственный оператор IF, содержащий простое условие, то существует два пути через код: один если условие оператора IF имеет значение TRUE и один — если FALSE.

Q: *Какое рекомендуемый максимальный порог цикломатической сложности для модуля?*

Big O нотация нужна для описания сложности алгоритмов. Для этого используется понятие времени.

O(1) - одна операция

O(n) — линейная сложность
Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.

O(log n) — логарифмическая сложность
Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов.

O(n2) — квадратичная сложность
Такую сложность имеет, например, алгоритм сортировки вставками. В канонической реализации он представляет из себя два вложенных цикла: один, чтобы проходить по всему массиву, а второй, чтобы находить место очередному элементу в уже отсортированной части. Таким образом, количество операций будет зависеть от размера массива как n * n, т. е. n2.

### Параллельное программирование. Многозадачность и многопоточность

Сложность: **высокая**
Грейд: **19**

Многозадачность — свойство операционной системы или среды выполнения обеспечивать возможность параллельной (или псевдопараллельной) обработки нескольких задач. Истинная многозадачность операционной системы возможна только в распределённых вычислительных системах.

Процессная многозадачность (основанная на процессах — одновременно выполняющихся программах). Здесь программа — наименьший элемент управляемого кода, которым может управлять планировщик операционной системы. Более известна большинству пользователей (работа в текстовом редакторе и прослушивание музыки).
Поточная многозадачность (основанная на потоках). Наименьший элемент управляемого кода — поток (одна программа может выполнять 2 и более задачи одновременно).

Многопоточность — свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени. При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины.

Q: *Что такое блокировка кода?*

Q: *Что такое асинхронность в программировании?*

Q: *Что такое семафор?*

### Рефлексия (отражения) в программировании

Сложность: **средняя**
Грейд: **19**

Рефлексия (отражение) — процесс, во время которого программа может отслеживать и модифицировать собственную структуру и поведение во время выполнения

### Аспектно-ориентированное программирование (АОП)

Сложность: **средняя**
Грейд: **19**

АОП — аспектно-ориентированное программирование — это парадигма, направленная на повышение модульности различных частей приложения за счет разделения сквозных задач. Для этого  к уже существующему коду добавляется дополнительного поведение, без изменений в изначальном коде.

Аспекты — это вынесенный отдельно код, который можно многократно переиспользовать и улучшать.

### Что такое DSL? Зачем нужен?

Сложность: **средняя**
Грейд: **19**

Предметно-ориентированные языки (DSL) — это языки программирования с более высоким уровнем абстракции, которые отражают специфику решаемых с их помощью задач. Такие языки оперируют понятиями и правилами из определенной предметной области.

Q: *Чем предметно-ориентированные языки отличаются от «настоящих» языков программирования?*

Предметно-ориентированные языки обычно не такие сложные, как языки общего назначения, например Java, C или Ruby. Как правило, предметно-ориентированные языки разрабатываются в сотрудничестве со специалистами в той сфере деятельности, для которой проектируется язык. Зачастую для использования таких языков не требуется квалификация разработчика и на них программируют люди, хорошо разбирающиеся в предметной области.

Q: *Чем отличается внутренний DSL от внешнего?*

Q: *Пример dsl?* (Jenkins pipeline)