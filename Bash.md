## Bash <!-- {docsify-ignore} -->

### exit code

Сложность: **низкая**

<!--Автор: @rogordeev -->

#### Вопрос:

Как понять, что команда в \*nix выполнилась без ошибок?

#### Ответ:

Исполняемый файл после завершения возвращает родительскому процессу exit code код. В POSIX это целое число от 0 до 255;
Нужно для того, чтобы понимать, успешно завершился процесс (exit code == 0) или нет.
Посмотреть:

```bash
echo "Hello world!" # исполняемый файл
echo $? # успешно завершился или нет
```

#### Дополнительные вопросы:

Q: *Как используют операторы `&&` и `||`?*

A: Условные операторы, удобные для использования в однострочниках:

```bash
true && echo "True" || echo "False"
```

Оператор проверяет exit code, если он 0 - работает `&&`, иначе `||`.

______________________________________________________________________

### `| grep`

Сложность: **низкая**

<!--Автор: @rogordeev -->

#### Вопрос:

Что такое pipe `|` в однострочнике `tail -f /var/log/dmesg.log | grep 'ERR'`? Что делают команды?

#### Ответ:

Это однонаправленный канал межпроцессного взаимодействия.

```bash
tail -f /var/log/dmesg.log | grep 'ERR'
```

Данные из STDOUT tail попадут в STDIN grep и тот отфильтрует строки с токеном ERR, в консоль они не выведутся.

Автор идеи каналов, Дуглас Макилрой (Malcolm Douglas McIlroy) также известен как автор одного из принципов Unix - "делайте что-то одно, но делайте это хорошо" (Do One Thing And Do It Well). В этом подходе простые, небольшие программы работают вместе, передавая друг другу данные.

______________________________________________________________________

### Бинарник

Сложность: **низкая**

<!--Автор: @rogordeev -->

#### Вопрос:

Разработчик передал нам бинарный файл утилиты, которая будет очень полезна для нашего тестирования - `readstream`. В ней захардкожен источник данных, результат чтения - json. \
Как её запускать локально?

#### Ответ:

Понадобится сделать файл исполняемым, возможно стоит убедиться, что файл собран под нашу платформу

```bash
chmod +x readstream
file readstream
> readstream: Mach-O 64-bit executable x86_64
```

Дальше файл можно запускать:
по относительному пути

```
ls .
> readstream
./readstream
```

или добавить путь к папке с ним в PATH: `PATH=~/readstreamdir:$PATH`

______________________________________________________________________

### Пишем скрипт

Сложность: **низкая**

<!--Автор: @rogordeev -->

#### Вопрос:

С чего должен начинаться скрипт? Как его запустить?

#### Ответ:

Скрипты в Unix начинаются с указания интерпретатора, который будет выполнять дальше код в теле скрипта

```bash
cat script.sh
#!/bin/bash
...
```

Перед запуском файл скрипта нужно сделать исполняемым - `chmod +x script.sh`.\
Выражение `#!` называется she-bang. Нужен он для того, чтобы не указывать интерпретатор в строке запуска e.g. `./script.sh` вместо `/bin/bash script.sh`

#### Дополнительные вопросы:

Q: *Возможно вы захотите поделиться скриптом с коллегой, что можно сделать, чтобы скрипт у него тоже запустился? У него может быть Linux, например.*

A: Использовать в she-bang `env`, предоставив ему найти нужный интерпретатор.

```bash
#!/usr/bin/env bash
```

POSIX-совместимые UNIX гарантируют, что `env` будет на своем месте.

______________________________________________________________________

### Итератор в bash

Сложность: **средняя**

<!--Автор: @rogordeev -->

#### Вопрос:

Продавцы Ozon жалуются, что иногда для товаров ошибочно показываются нулевые остатки (товара нет в наличии). Мы попробовали воспроизвести на сайте - не удалось.

Есть предположение, что HTTP API, которое сообщает остаток по номеру товара, иногда ошибочно возвращает 0.

http://api.prod.ozon.ru/tovar/{id}/stock

Как, используя shell, запросить его много раз подряд, для проверки?

#### Ответ:

Считаем, что нам не нужна авторизация и т.п.

```bash
for i in {1..100}
do
    curl http://api.prod.ozon.ru/tovar/{id}/stock
done
> 1
....
> 1
```

#### Дополнительные вопросы:

Q: *Наверное результат будет не очень наглядным, как его сделать понятнее?*

A: Добавить после done `| sort | uniq -c` - результаты будут сгруппированы по значению и посчитано число вхождений.

______________________________________________________________________

### Итерация по строкам файла

Сложность: **сложная**

<!--Автор: @rogordeev -->

#### Вопрос:

Нам нужно проверить, что переписанное api поиска http://api.prod.ozon.ru/search возвращает непустой ответ на top100 поисковых запросов.

Все запросы за последний месяц аналитик выгрузил нам в файл формата:

```txt
<запрос>,<счётчик>
```

Запросов получилось больше ста, но они правильно отсортированы по количеству.

curl для api выглядит так:

```bash
  curl -X POST "http://api.prod.ozon.ru/search" \
    -H "accept: application/json" \
    -H "Content-Type: application/json" \
    -d "{\"searchPhrase\": \"<поисковый запрос>\" }" ; 
```

Как, используя shell, подставить в api нужные поисковые строки?

#### Ответ:

Если файл правильно отсортирован - нам нужно прочитать первые 100 строк:

```bash
head -n 100 <datafile>
```

и отделить запрос от счетчика

```bash
head -n 100 <datafile> | cut -d',' -f1
# или с awk
head -n 100 <datafile> | awk -F ',' '{print $1}'
```

для каждой строки надо выполнить запрос -

```
for query in "$( head -n 100 <datafile> | cut -d',' -f1 )"
do 
    curl -X POST "http://api.prod.ozon.ru/search" \
    -H "accept: application/json" \
    -H "Content-Type: application/json" \
    -d "{\"searchPhrase\": \"$query\" }" ;
done
```

#### Дополнительные вопросы:

Q: *Поисковые запросы могут состоять из нескольких слов, скрипт будет работать с такими запросами?*

A: Нет, конструкция `for` разделяет по табуляции, пробелам, новым строкам, тогда нам больше подойдет `while read`

```
head -n 100 <datafile> | cut -d',' -f1 | while read line
do
    ...
done
```

______________________________________________________________________
